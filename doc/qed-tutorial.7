'\" t
.\"     Title: qed-tutorial
.\"    Author: Robert Pike, Sean Jensen (ed.)
.\" Generator: Asciidoctor 2.0.12
.\"      Date: 2021-02-20
.\"    Manual: \ \&
.\"    Source: \ \&
.\"  Language: English
.\"
.TH "QED\-TUTORIAL" "7" "2021-02-20" "\ \&" "\ \&"
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ss \n[.ss] 0
.nh
.ad l
.de URL
\fI\\$2\fP <\\$1>\\$3
..
.als MTO URL
.if \n[.g] \{\
.  mso www.tmac
.  am URL
.    ad l
.  .
.  am MTO
.    ad l
.  .
.  LINKSTYLE blue R < >
.\}
.SH "NAME"
qed\-tutorial \- Programming in Qed: A Tutorial
.SH "SYNOPSIS"
.sp
man 7 qed\-tutorial
.SH "INTRODUCTION"
.sp
\fBQed\fP is a programmable text editor, intended for use primarily
by programmers.
For the average user, \fBQed\fP\(cqs power will likely be unnecessary,
even troublesome, and its use is discouraged.
For a knowledgeable user who is willing to learn how to use it
properly, however, \fBQed\fP is a powerful tool, both when used
as an editor or as a (rather idiosyncratic and low\-level) programming
language.
.sp
\fBQed\fP is very nearly a superset of the University of Toronto
\fBUNIX\fP version 6 editor,
\fBEd\fP, which is itself a strict superset of standard \fBEd\fP.
This document assumes considerable familiarity with the standard
editor,
and some acquaintance with the new features of the U. of T. version.
The features of U. of T. \fBEd\fP not found in regular version
6 \fBEd\fP include: the \f(CR*\fP address separator,
two character error messages (a query followed by a character
which indicates the error, e.g. \f(CR?s\fP for a failed substitution),
a simple undo \f(CRu\fP command,
and a join \f(CRj\fP command of somewhat greater generality
than the *PWB* version.
(The new features used in this tutorial will be briefly explained as
they turn up.)
There is an add\-on document for U. of T. \fBEd\fP
which describes the enhancements and modifications, at user level,
made at U. of T.
.sp
This tutorial is not a complete description of the capabilities of \fBQed\fP.
Rather, it is an attempt to familiarize the programmer with
the general ways in which \fBQed\fP operates,
emphasizing the programming techniques which clarify and simplify its use.
A full description of the commands and features of \fBQed\fP
may be found in the manual section, \f(CRqed(1)\fP.
.sp
Before beginning
the discussion of \fBQed\fP,
some warning should be given.
\fBUNIX\fP \fBEd\fP is closely based on a version of \fBQed\fP,
running under the \fBGCOS\fP operating system,
which was written by Dennis Ritchie and Ken Thompson.
When Dennis Ritchie wrote \fBEd\fP,
he removed many of the features,
including most of the programming capabilities,
but left in most of the text editing power.
Although the \fBQed\fP described here is significantly
more complex and powerful than \fBEd\fP
(and quite unrelated to the \fBGCOS\fP \fBQed\fP),
its increase in power is not proportionate to its
increase in complexity.
In short, \fBEd\fP is a very powerful editor, and for general
editing jobs quite sufficient.
\fBQed\fP simplifies some more complicated tasks,
and its multifile capability and programmability make many things possible which
cannot be done in \fBEd\fP,
but to use it well requires a fairly thorough understanding
of its operation, which is fairly intricate.
.sp
\fBQed\fP has several drawbacks that should be admitted early.
\fBQed\fP programs can be difficult to read, even if done
carefully, since it operates at about the level of
a particularly cryptic assembler.
A careless user can easily damage files using
\fBQed\fP incorrectly, but
it is much harder to accidentally cause trouble
with the U. of T. \fBQed\fP than earlier ones,
as the implementors worked very hard at
safeguarding.
The safeguards are strong enough
that occasional users who desire a particular \fBQed\fP
feature for one editing job need not feel in danger of
making a serious mistake.
\fBQed\fP\(cqs power can lead
the user astray;
it has far more power than is needed for most editing jobs.
As an illustrative but rather artificial example,
consider the problem of reversing the lines of a file,
so that the last line appears at the top,
and the first at the bottom,
with the contents of the lines unchanged.
At first, this may seem a problem for \fBQed\fP if it is only
to be done once or twice (if it is to be done often,
we would certainly write a C program!),
but it is very easy to do in \fBEd\fP:
.sp
.if n .RS 4
.nf
.fam C
g/^/m0
.fam
.fi
.if n .RE
.sp
(For readability\(cqs sake,
it will be the convention in this tutorial to show user input
aligned with the left margin,
and editor output offset by a tab from the left margin.
In actual practice on the terminal screen,
the editor output is left\-aligned on
the left margin, exactly as the input is.)
.sp
A second, slightly more complicated example is the problem of
placing two columnar files, say files generated by \f(CRls\fP,
alongside each other in a buffer.
\fBEd\fP can again do the job quite well:
.sp
.if n .RS 4
.nf
.fam C
$ ed file1
        142
\&.=
        15
r file2
        153
\&.=
        30
1ka
16,30 g/^/m\(aqa\(rs
+ka
g/^/ .,+j/       /
.fam
.fi
.if n .RE
.sp
How does it work?
After reading in the two files, each of 15 lines,
the first line is marked (\f(CR1ka\fP).
Then each line in the second file is moved to
the line marked \f(CRa\fP, setting \f(CRdot\fP to the moved line,
and the mark is transferred to the next line in the first file
(\f(CR+ka\fP).
The backslash in the global command line is necessary
to terminate the scan of the target address for the move.
The last command joins each line to the next,
separated by a tab (the white space between the slashes on the
join \f(CRj\fP command, a facility in U. of T. \fBEd\fP).
Because the global command marks all lines for execution
before running the command list on any of the lines,
after the join the second of each pair of lines has effectively
disappeared from the range of lines of the global,
and each execution of the global command list joins
a line of the first file with its corresponding line in the second.
.sp
The above example demonstrates several things.
First, \fBEd\fP is considerably more powerful than most of its
users realize.
When first given the problem, most users (including the author!)
assume it is a task best handled by \fBQed\fP.
Second, editor programming often requires the subtle interaction
of many commands: the global join is an excellent example.
Therefore, debugging editor programs can be difficult.
(\fBQed\fP has a
tracing feature which greatly simplifies debugging in some cases.)
Third, editor programs are usually difficult to read and understand.
.sp
This preamble may sound discouraging, but it is only
promoting realism.
When used well and carefully, \fBQed\fP can be a great time saver,
fun to work with, and sometimes even elegant.
The original \f(CRtroff\fP version of this document was written using \fBQed\fP,
storing sequences like \f(CR\(rsfBQed\(rsfP\fP in registers
to save typing.
.sp
Well, if you\(cqve read this far,
you must be determined,
so you\(cqre ready to learn about buffers.

.SH "BUFFERS"
.sp
\fBEd\fP has one buffer: one scratch area in which to keep text.
\fBQed\fP has 56,
labeled by lower case alphabetics \f(CRa\fP to \f(CRz\fP,
upper case alphabetics \f(CRA\fP to \f(CRZ\fP,
and, for reasons worth ignoring at this point,
the characters \f(CR{\fP, \f(CR|\fP, \f(CR}\fP, and \f(CR~\fP.
Each buffer has its own associated \f(CR.\fP (\fIdot\fP), \f(CR$\fP (\fIdollar\fP), and filename.
The easiest way to see how they work is to
\f(CRcd\fP to a directory with about ten \f(CRC\fP source files and type:
.sp
.if n .RS 4
.nf
.fam C
$ qed *.c
.fam
.fi
.if n .RE
.sp
(we\(cqve already accomplished something which is impossible in \fBEd\fP!)
If you were in the \fBQed\fP source directory, you would see
something like
.sp
.if n .RS 4
.nf
.fam C
        a .82        address.c
        b .121        blkio.c
        c .702        com.c
        d .466        getchar.c
        e .284        getfile.c
        f .119        glob.c
        g .725        main.c
        h .209        misc.c
        i .135        move.c
        j .474        pattern.c
        k .156        putchar.c
        l .38        setaddr.c
        m .128        string.c
        n .418        subs.c
        o .220        utf.c
        p .153        utfio.c
        q .36        utfstr.c
.fam
.fi
.if n .RE
.sp
The first column is the buffer name,
the second column is the value of \f(CR.\fP (\fIdot\fP) in the buffer, which, on
first reading in of a file is set to
the value of \f(CR$\fP (\fIdollar\fP) in the buffer, that is, the
number of lines, and the last column is the file name local
to that buffer.
.sp
\fBQed\fP is now waiting for a command. Type \f(CRn\fP
.sp
.if n .RS 4
.nf
.fam C
n
        a .82        address.c
        b  121        blkio.c
        c  702        com.c
        d  466        getchar.c
        e  284        getfile.c
        f  119        glob.c
        g  725        main.c
        h  209        misc.c
        i  135        move.c
        j  474        pattern.c
        k  156        putchar.c
        l  38        setaddr.c
        m  128        string.c
        n  418        subs.c
        o  220        utf.c
        p  153        utfio.c
        q  36        utfstr.c
.fam
.fi
.if n .RE
.sp
and look at the output. It should be nearly identical to the above output \fBQed\fP
printed when it loaded the files on start up, but now there is only one \f(CR.\fP,
indicating that buffer \f(CRa\fP is the current buffer.
The \f(CRn\fP (for \fInames\fP) command is \fBQed\fP\(cqs equivalent of \f(CRls \-l\fP.
.sp
Now do an \f(CRf\fP command. You\(cqll see
.sp
.if n .RS 4
.nf
.fam C
f
        a .82        address.c
.fam
.fi
.if n .RE
.sp
In \fBQed\fP, the \f(CRf\fP command tells you more than just the file name.
Now change something in the file, say substitute out a tab
or delete an empty line, and do another \f(CRf\fP:
.sp
.if n .RS 4
.nf
.fam C
f
        a\(aq.82        ddress.c
.fam
.fi
.if n .RE
.sp
The prime tells you that the contents of the buffer are
known to differ from the named file.
Now try
.sp
.if n .RS 4
.nf
.fam C
bb f
        b .121        blkio.c
.fam
.fi
.if n .RE
.sp
The \f(CRbb\fP and \f(CRf\fP can be placed on the same line,
as \fBQed\fP does not require a newline after most commands.
The \f(CRbb\fP says \fIchange to buffer\fP \f(CRb\fP.
Buffer \f(CRb\fP is now the current buffer, as indicated
by the dot.
If you browse around the buffer for a while,
you will see that it is really a world unto itself,
but changing back to buffer \f(CRa\fP by a \f(CRba\fP command
will reset you back to the original file,
with \fIdot\fP still at whatever line it was when you typed \f(CRbb\fP.
.sp
Why have multiple buffers?
For one thing, we can copy or move text between buffers.
Go back to buffer \f(CRa\fP and isolate a subroutine, marking
its beginning with \f(CRka\fP and its last line with \f(CRkb\fP.
Then type
.sp
.if n .RS 4
.nf
.fam C
\(aqa,\(aqb tz0
.fam
.fi
.if n .RE
.sp
This is a regular copy command, but the \f(CRz\fP after the \f(CRt\fP
tells \fBQed\fP that the text is to be copied to buffer \f(CRz\fP.
The \f(CR0\fP is the usual address, but is interpreted in buffer
\f(CRz\fP rather than the current buffer.
Of course, if there is no buffer name character after the \f(CRt\fP
then \fBQed\fP performs the copy command within the current buffer.
Do another \f(CRn\fP: you will see that you are currently
in buffer \f(CRz\fP, and \fIdot\fP is set to the last line copied.
The \f(CRm\fP (\fImove\fP) command behaves similarly.

.SH "SPECIAL CHARACTERS (1)"
.sp
Change to buffer \f(CRz\fP and clear it:
.sp
.if n .RS 4
.nf
.fam C
bz 0,$d
.fam
.fi
.if n .RE
.sp
Note that line \f(CR0\fP is a valid address for deletion.
\f(CR,d\fP also would work here, and neither idiom
generates an error if the buffer is empty.
As well, you could have typed
.sp
.if n .RS 4
.nf
.fam C
bz Z
.fam
.fi
.if n .RE
.sp
The \f(CRZ\fP (\fIzero\fP) command unequivocally clears the buffer,
even its remembered file name.
Now do the following:
.sp
.if n .RS 4
.nf
.fam C
ap g/^[a\-zA\-Z_].*(/p
        g/^[a\-zA\-Z_].*(/p
.fam
.fi
.if n .RE
.sp
The append commands (\f(CRa\fP, \f(CRi\fP and \f(CRc\fP) all accept a single line
of input typed on the command line, with a space or tab separator
between the command and its input.  As always, a \f(CRp\fP suffix
causes the command to print its result.
Buffer \f(CRz\fP now contains a possibly useful command for \fBQed\fP
(do you know what it does?) which we can
call up when desired.
.sp
Now read some \f(CRC\fP source into buffer \f(CRb\fP if there isn\(cqt already
some there, and try out the buffer like this:
.sp
.if n .RS 4
.nf
.fam C
bb
\(rsbz
        initio(void)
        getline(addr_t tl, int *lbuf)
        putline(void)
        blkio_r(int b, int *buf)
        blkio_w(int b, int *buf)
.fam
.fi
.if n .RE
.sp
The sequence \f(CR\(rsbz\fP means \fIinsert
the contents of buffer\fP \f(CRz\fP \fIinto my input stream here\fP.
The final newline in the buffer
is replaced by the one typed after the \f(CRz\fP,
so that if you decided later that you wanted to know the line
numbers as well, you could tag a \f(CR.=\fP command on the end:
.sp
.if n .RS 4
.nf
.fam C
\(rsbz .=
        initio(void)
        43
        getline(addr_t tl, int *lbuf)
        51
        putline(void)
        81
        blkio_r(int b, int *buf)
        108
        blkio_w(int b, int *buf)
        116
.fam
.fi
.if n .RE
.sp
Although most \fBQed\fP commands can be arbitrarily grouped on a line,
the global \f(CRg\fP command, as in \fBEd\fP,
still reads the full line for its command list,
which in this case is \f(CRp .=\fP.
.sp
The above example is very important, as it uses a mixture of
buffer input and terminal input to run a command,
an all\-pervading concept in \fBQed\fP programming.
.sp
\f(CR\(rsbz\fP is called a \fIspecial character\fP, although in some sense
it isn\(cqt really a character at all, as it gets
completely replaced with the contents of buffer \f(CRz\fP.
The \f(CR\(rsbz\fP is interpreted
\fBwhenever input is expected\fP,
not just when commands are being read.
Try the following examples:
.sp
.if n .RS 4
.nf
.fam C
by a
\(rsbz
\&.
p
        g/^[a\-zA\-Z_].*(/p
ap \(rsbz
        g/^[a\-zA\-Z_].*(/p
!echo "\(rsbz"
        g/^[a\-zA\-Z_].*(/p
        !
.fam
.fi
.if n .RE
.sp
The buffer could contain multiple lines, which would be handled as usual.
We could, for example, save in a buffer our example from the
introduction, which merged two columnar files alongside each other,
and invoke it when desired just as we invoked the global search above.
But care must be exercised here, as the newlines in the buffer,
except for the last,
are also placed in the input stream.  If we were to type, with that
multiline buffer in \f(CRz\fP, the command
.sp
.if n .RS 4
.nf
.fam C
s/x/\(rsbz/p
.fam
.fi
.if n .RE
.sp
mistakenly
expecting that buffer \f(CRz\fP had just a single line of text,
say a frequently typed word, we would really be saying:
.sp
.if n .RS 4
.nf
.fam C
s/x/1ka
16,30 g/^/m\(aqa\(rs
    +ka
g/^/ .,+j/       //p
.fam
.fi
.if n .RE
.sp
This would, of course, cause an immediate error, and since \fBQed\fP
always returns to terminal input when an error occurs,
no damage would be done.
Sometimes, though, such mistakes can cause strange results!
.sp
If you did try the above command, the error message would be
.sp
.if n .RS 4
.nf
.fam C
        ?bz2.0 ?x
.fam
.fi
.if n .RE
.sp
\fBQed\fP gives a traceback on errors.
The elements of the traceback are of the form
.sp
.B error code format
.br
.sp
.if n .RS 4
.nf
.fam C
?bXM.N
.fam
.fi
.if n .RE
.sp
where \f(CRX\fP is the buffer name, \f(CRM\fP the line number, and \f(CRN\fP the character
number of the character at which the error was recognized.
In the above example, the \fIsubstitute\fP command found a syntax error (\f(CR?x\fP)
when it read the newline,
so the error occurred at the beginning (\f(CR.0\fP) of line \f(CR2\fP of buffer \f(CRz\fP.
If input is nested,
the deepest\-called buffer is
printed first.
.sp
It is a good idea to pause here and look carefully over what
has been covered so far, as
the concept of using a buffer to store regular
files or command input interchangeably
is really the heart of \fBQed\fP.
Before reading on,
use \fBQed\fP for a while
to familiarize yourself with the system of buffers,
and try out a few simple buffers
for repetitive editing tasks.
.sp
\fBQed\fP has a fair number of special characters
for various purposes.  In the rest of this section
we will look briefly at some of the simpler ones
to give you some insight into how they behave.
First, enter buffer \f(CRz\fP again and append:
.sp
.if n .RS 4
.nf
.fam C
bz
a
\(rsFa
\(rsFb
\&.
.fam
.fi
.if n .RE
.sp
and then look at what \fBQed\fP has appended to the buffer:
.sp
.if n .RS 4
.nf
.fam C
\-,p
        address.c
        blkio.c
.fam
.fi
.if n .RE
.sp
The special character \f(CR\(rsFa\fP means  \fIthe file name
for buffer\fP \f(CRa\fP,
and, like all special characters, is
interpreted whenever input is expected.
The special character \f(CR\(rsf\fP is a shorthand for
\fIthe saved file name in the current buffer\fP.
Try
.sp
.if n .RS 4
.nf
.fam C
f junk
        z\(aq.2        junk
w
        18
!ls \(rsf
        junk
        !
.fam
.fi
.if n .RE
.sp
Idioms such as
.sp
.if n .RS 4
.nf
.fam C
!cc \(rsf
.fam
.fi
.if n .RE
.sp
are very common.
If your file name is long, \f(CR\(rsf\fP can save much typing.
If the file name is changed, through an \f(CRf\fP or \f(CRe\fP command,
the name actually associated with `\(rsf\(aq is only changed when
the new name is completely read in.
Thus, you can type
.sp
.if n .RS 4
.nf
.fam C
e \(rsf
.fam
.fi
.if n .RE
.sp
to reinitialize a buffer, or
.sp
.if n .RS 4
.nf
.fam C
e /sys/src/cmd/\(rsf
.fam
.fi
.if n .RE
.sp
to edit the system version of a program.
There is another special character like \f(CR\(rsf\fP,
but it is more useful for programming.
\f(CR\(rsB\fP means \fIthe current buffer name\fP.
Try
.sp
.if n .RS 4
.nf
.fam C
!echo \(rsB
        z
        !
.fam
.fi
.if n .RE

.SH "SPECIAL CHARACTERS (2)"
.sp
The easiest way to gain familiarity with
the more abstruse characters is to use them
in messages, which are a special case of comments.
A comment starts with a double quote \f(CR"\fP, and continues
until the first following double quote, or the end
of the line, whichever is first.
The line is ignored by
\fBQed\fP, except that dot is set to the addressed line, if there is one:
.sp
.if n .RS 4
.nf
.fam C
4 " This comment sets dot to line 4
.fam
.fi
.if n .RE
.sp
Messages are just like comments, except that the first character after
the double quote is another double quote.
If the message ends with a double quote rather than a
newline, no newline is printed:
.sp
.if n .RS 4
.nf
.fam C
bx
" hi
"" hi
         hi
"" hi there "
         hi there |<\- cursor is left on this line
""Current buffer: b\(rsB
        Current buffer: bx
.fam
.fi
.if n .RE
.sp
This last example is mildly interesting.
Can we save the command in, say, buffer \f(CRx\fP
and call it back, from any buffer, when desired?
.sp
.if n .RS 4
.nf
.fam C
bx Z
ap ""Current buffer: b\(rsB
        ""Current buffer: bx
bA \(rsbx
        Current buffer: bx
.fam
.fi
.if n .RE
.sp
Oops! In principle, it can be done, since the current buffer is the one
we are working on, not the one being read for input.
But, to put the characters \f(CR\(rsB\fP in a buffer,
we must delay their interpretation so that
they are not replaced with the buffer name until
read back as command input.
In most systems on \fBUNIX\fP, this is done
by typing an extra backslash,
but things are more civilized in \fBQed\fP.
In \fBQed\fP, special characters are
\fIdelayed,\fP
not quoted.
Perhaps it\(cqs simplest just to state the rules:
.sp
.B special characters
.br
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fB\(rsX\fP\fP is a special character if \f(CRX\fP is one of
\f(CR\fBb\fP\fP, \f(CR\fBB\fP\fP, \f(CR\fBc\fP\fP, \f(CR\fBf\fP\fP, \f(CR\fBF\fP\fP, \f(CR\fBl\fP\fP, \f(CR\fBN\fP\fP, \f(CR\fBp\fP\fP, \f(CR\fBr\fP\fP, \f(CR\fBu\fP\fP, \f(CR\fBU\fP\fP, \f(CR\fBz\fP\fP, or \f(CR\fB"\fP\fP,
sometimes (as with \f(CR\(rsb\fP) followed by a buffer name. It
is interpreted \fIimmediately\fP.
(We will see what all these special characters are in due course.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fB\(rsZ\fP\fP, where \f(CRZ\fP is \fBnot\fP one of the above,
undergoes no interpretation at all.
In particular, the backslash is not stripped away.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fB\(rsc\fP\fP is reduced on scanning to \f(CR\(rs\fP, but not re\-scanned.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fB\(rs\(aqX\fP\fP is equivalent to \f(CR\(rsX\fP, but special characters embedded in \f(CR\(rsX\fP
are not interpreted.
.RE
.RE
.sp
Things are a little different in regular expressions, but
let\(cqs ignore them for the moment.
These four rules, simple though they are,
define the interpretation of backslashes in \fBQed\fP.
Note that \f(CR\(rs\(rsZ\fP, where \f(CRZ\fP is again \fInot\fP one of the above characters,
remains \f(CR\(rs\(rsZ\fP, but if \f(CRZ\fP \fIis\fP
special, say \f(CRf\fP when the saved file name is \f(CRjunk.c\fP, then
\f(CR\(rs\(rsf\fP becomes \f(CR\(rsjunk.c\fP.
.sp
Now we know how to install a \f(CR\(rsB\fP in our buffer: we delay
its interpretation by putting a \f(CRc\fP
between the backslash and the \f(CRB\fP.
(The \f(CRc\fP is for \fIcharacter\fP,
or (it is rumoured), for \fIMr. E. S. Cape,\fP inventor of the backslash.)
The \f(CR\(rscB\fP will reduce to a literal \f(CR\(rsB\fP when typed in:
.sp
.if n .RS 4
.nf
.fam C
bx Z
ap ""Current buffer: b\(rscB
        ""Current buffer: b\(rsB

bA \(rsbx
        Current buffer: bA
bB \(rsbx
        Current buffer: bB
.fam
.fi
.if n .RE
.sp
That\(cqs better! Since \f(CR\(rscc\fP will reduce to \f(CR\(rsc\fP,
the number of \f(CRc\fP\-s present is always just the
number of times the interpretation is to be delayed.
.sp
To decide how many delays are necessary, here is the list
of input forms that cause characters to be interpreted:
.sp
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
terminal input
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
commands or text (such as that saved in buffers) invoked using a special character
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
command lines for the \f(CR\fBg\fP\fP, \f(CR\fBv\fP\fP, \f(CR\fBG\fP\fP, \f(CR\fBV\fP\fP, or \f(CR\fBh\fP\fP
commands (\f(CRg\fP and \f(CRv\fP are
the same as in \fBEd\fP; we\(cqll see the others a little later)
.RE
.RE
.sp
Note that characters are \fInot\fP
interpreted when buffers are read from or written to files,
or moved or copied with the \f(CRm\fP or \f(CRt\fP commands.
Experience is a great help here, so let\(cqs look at some examples:
.sp
.B delay and substitution
.br
.sp
.if n .RS 4
.nf
.fam C
bx                                "switch to buffer x
s/$/\(rsB/                        "appends x to current line
s/$/\(rscB/                "appends \(rsB to current line
s/$/\(rsccB/                "appends \(rscB to current line
.fam
.fi
.if n .RE
.sp
but:
.sp
.B delay and global
.br
.sp
.if n .RS 4
.nf
.fam C
g/xxxx/ s/$/\(rsccB/        "appends \(rsB to all lines matching /xxxx/
.fam
.fi
.if n .RE
.sp
appends \f(CR\(rsB\fP to all lines with \f(CRxxxx\fP;
the extra \f(CRc\fP is because the command is in a global command string.
Let\(cqs say we want to change all the \f(CR\(rsn\fP\-s to be \f(CR\(rsn\(rst\fP.
There are two ways:
.sp
.if n .RS 4
.nf
.fam C
,s/\(rsn/\(rsn\(rst/
" equivalent to
,s/\(rscn/\(rscn\(rsct/
" or
g/\(rsn/ s/\(rsn/\(rsn\(rst/
.fam
.fi
.if n .RE
.sp
No delays are necessary because \f(CR\(rsn\fP and \f(CR\(rst\fP are not special characters,
but delaying them once makes no difference:
the \f(CR\(rscn\fP just becomes \f(CR\(rsn\fP, anyway.
(Warning: \f(CR\(rsn\fP has special meaning in the replacement text of a
substitution in U. of T. \fBEd\fP.)
.sp
While we\(cqre dealing with globals, it is a good time to introduce the \f(CR\(rsN\fP
special character.
It means, simply, a \fInewline\fP,
and is useful primarily because we can delay it in the usual way.
Commands, such as \f(CRr\fP, which deal with filenames, must often
be followed by a newline, but can be dealt with using \f(CR\(rsN\fP
in globals.
The \fBEd\fP sequence
.sp
.if n .RS 4
.nf
.fam C
g/xxxx/ r\(rs
\&.=
.fam
.fi
.if n .RE
.sp
can be put all on one line in \fBQed\fP:
.sp
.if n .RS 4
.nf
.fam C
g/xxxx/ r\(rscN .=
.fam
.fi
.if n .RE
.sp
The newline is delayed.
In original version 6 \fBEd\fP, it is impossible to
globally
substitute a newline into lines,
but it\(cqs straightforward (by \fBQed\fP standards!) in \fBQed\fP:
.sp
.if n .RS 4
.nf
.fam C
g/xxxx/ s//\(rs\(rscN/p
.fam
.fi
.if n .RE
.sp
The \f(CR\(rs\(rscN\fP is a backslash followed by a delayed newline.
The \f(CR\(rscN\fP becomes \f(CR\(rsN\fP when scanned by the global \f(CRg\fP command,
and then becomes a newline when (re\-)read for each \f(CRs\fP substitution.
In \fBQed\fP (and U. of T. \fBEd\fP) we could also do this
by the functionally slightly different
.sp
.if n .RS 4
.nf
.fam C
g/xxxx/ s//\(rs\(rs
/p
.fam
.fi
.if n .RE
.sp
[Do you see the difference?].
.sp
Backslashes in general are handled more reasonably in \fBQed\fP
than in other \fBUNIX\fP programs.
Because special characters are \fIdelayed\fP rather than \fIquoted,\fP
the number of characters required to insert a special character,
with interpretation delayed \f(CRn\fP times,
is just \f(CRn+2\fP or \f(CRn+3\fP,
rather than exponential in \f(CRn\fP.
A \fBtroff\fP
line with 31 backslashes, a not\-unheard\-of
occurrence,
would in \fBQed\fP have a single backslash followed by five \f(CRc\fP characters.
(And would be much easier to understand, text edit, and debug!)
.sp
In particular, \fBQed\fP handles backslashes differently from \fBEd\fP.
As mentioned earlier, the \fBEd\fP command
.sp
.if n .RS 4
.nf
.fam C
s2/"/\(rs\(rsn"/p
.fam
.fi
.if n .RE
.sp
is simply
.sp
.if n .RS 4
.nf
.fam C
s2/"/\(rsn"/p
.fam
.fi
.if n .RE
.sp
in \fBQed\fP, because \f(CR\(rsn\fP is \fInot\fP a special character.
There are, however, characters which are not \(lqspecial\(rq
in the sense
we are using here, but are \(lqmagic\(rq in
that they have non\-literal meaning.
The most obvious are characters such as \f(CR.\fP and \f(CR$\fP in regular
expressions, which must be \fIquoted\fP with a backslash to remove
their special meaning and make them literal.
(It becomes clear after using \fBQed\fP, or even \fBEd\fP, for a while that
\fIall\fP
the magic characters in regular expressions and the like
should require a backslash to become
\(lqmagic\(rq,
rather than literal,
but the current choice is too wired\-in to the minds of
most \fBEd\fP users to be changed now.)
Because they are not special characters,
their interpretation need not be delayed:
they only mean something to the \f(CRs\fP \fIsubstitute\fP command.
None of the magic characters in the substitution
.sp
.if n .RS 4
.nf
.fam C
s/\(rs(\(rs.*\(rs)xxx$/\(rs1/
.fam
.fi
.if n .RE
.sp
require delaying when typed in or run from a global command:
.sp
.if n .RS 4
.nf
.fam C
g/xyz/ s/\(rs(\(rs.*\(rs)xxx$/\(rs1/
.fam
.fi
.if n .RE
.sp
.B Exercise
.br
.RS 4
.sp
Is the following command the same as the above substitution?
.sp
.if n .RS 4
.nf
.fam C
s/\(rsc(\(rsc.*\(rsc)xxx$/\(rsc1/
.fam
.fi
.if n .RE
.sp
Why or why not?
Is the following the same as the global substitution?
.sp
.if n .RS 4
.nf
.fam C
g/xyz/ s/\(rsc(\(rsc.*\(rsc)xxx$/\(rsc1/
.fam
.fi
.if n .RE
.sp
Try it to test your answers.
.RE
.sp
Because of these magic characters, two backslashes in a row \f(CR\(rs\(rs\fP
mean a single backslash \f(CR\(rs\fP in regular expressions;
otherwise it would be impossible to substitute
in a real backslash before a magic character:
.sp
.if n .RS 4
.nf
.fam C
a abc xyz def
s/xyz/\(rs\(rs&/p
        abc \(rsxyz def
up
        abc xyz def
s/xyz/\(rs\(rs\(rs&/p
        abc \(rs& def
.fam
.fi
.if n .RE
.sp
What about sequences like \f(CR\(rs\(rsB\fP?
Well, \f(CR\(rsB\fP is not a character at all,
but a \fIspecial character\fP (sorry for the terminology)
since it is
\fBimmediately\fP,
at the lowest level
of input, replaced by the current buffer name.
Since \f(CR\(rs\(rs\fP is \fInot\fP a special character,
and has non\-literal meaning only when found between
regular expression delimiters,
the substitute command itself never sees the second backslash.
All interpretation of special characters is done
\fIbefore\fP the substitute command sees them.
If the current buffer is buffer \f(CRa\fP, then
.sp
.if n .RS 4
.nf
.fam C
s/\(rs\(rsB/x/
.fam
.fi
.if n .RE
.sp
does exactly the same thing as
.sp
.if n .RS 4
.nf
.fam C
s/\(rsa/x/
.fam
.fi
.if n .RE
.sp
Also, because \fBQed\fP next converts \f(CR\(rs\(rs\fP to \f(CR\(rs\fP in
regular expressions,
.sp
.if n .RS 4
.nf
.fam C
s2/"/\(rs\(rsn"/p
.fam
.fi
.if n .RE
.sp
is the same as
.sp
.if n .RS 4
.nf
.fam C
s2/"/\(rsn"/p
.fam
.fi
.if n .RE
.sp
since \f(CR\(rsn\fP is not a special character.
.sp
\fBQed\fP saves the last used regular expression and replacement text
used in an \f(CRs\fP or \f(CRj\fP command,
so that they can be called back using \f(CR\(rsp\fP (for \fIpattern\fP)
and \f(CR\(rsr\fP (for \fIrighthand side\fP).
\f(CR\(rsp\fP is handy when you want to change the saved pattern.
If, for example, you start searching for \f(CRproc()\fP
and want the declaration, but find there are very many usages of \f(CRproc()\fP,
it is simple to find an occurrence of \f(CRproc()\fP at the beginning
of a line:
.sp
.if n .RS 4
.nf
.fam C
/proc()/
            x=proc();
//
            x=proc()*2;
/^\(rsp/
        proc(){
.fam
.fi
.if n .RE
.sp
\f(CR\(rsp\fP is of somewhat limited usefulness, as the null regular expression \f(CR//\fP
is essentially the same as \f(CR/\(rsp/\fP;
but \f(CR\(rsr\fP provides a new convenience.
Browsing through text doing repetitive substitution
is simplified considerably by using \f(CR\(rsr\fP :
.sp
.if n .RS 4
.nf
.fam C
s/apples/mangos and pears/p
        I ain\(aqt got no mangos and pears
//
        your mother\(aqs apples smelled like they were
s//\(rsr/p
        your mother\(aqs mangos and pears smelled like they were
.fam
.fi
.if n .RE
.sp
There is a danger with \f(CR\(rsp\fP and \f(CR\(rsr\fP :
if they contain delayed special characters,
each usage of \f(CR\(rsp\fP or \f(CR\(rsr\fP removes one delay.
If the current file name is \f(CRwylbur.ms\fP,
it may be difficult to deal with \f(CRtroff\fP font changes:
.sp
.if n .RS 4
.nf
.fam C
p
        editors such as Wylbur are so
s/Wylbur/\(rscfBWylbur\(rscfP/p
        editors such as \(rsfBWylbur\(rsfP are so
//
        Wylbur is also no good for
s//\(rsr/p
        wylbur.msBWylburwylbur.msP is also no good for
" Oops
.fam
.fi
.if n .RE
.sp
This is the sort of trouble which the \f(CR\(rs\(aq\fP special character can
circumvent.
\f(CR\(rs\(aqr\fP means the usual \f(CR\(rsr\fP, but with special characters inside
\fIuninterpreted\fP.
If we had used it above, things would have worked properly:
.sp
.if n .RS 4
.nf
.fam C
p
        editors such as Wylbur are so
s/Wylbur/\(rscfBWylbur\(rscfP/p
        editors such as \(rsfBWylbur\(rsfP are so
//
        Wylbur is also no good for
s//\(rs\(aqr/p
        \(rsfBWylbur\(rsfP is also no good for
" Much better
.fam
.fi
.if n .RE
.sp
\f(CR\(rsr\fP is also handy for fixing a certain class of mistakes:
.sp
.if n .RS 4
.nf
.fam C
p
        textp=get(a\->text.fdes);
s/text/tbuf/p
        tbufp=get(a\->text.fdes);
" Oops again
        textp=get(a\->tbuf.fdes);
" Got it!
.fam
.fi
.if n .RE
.sp
The \fBQed\fP idiom \f(CRus2//\(rs\(aqr/p\fP
undoes (\f(CRu\fP) what you just did wrong, then substitutes (\f(CRs\fP) again (\f(CR//\fP) on the \fIsecond\fP (\f(CR2\fP) match in the line.
.sp
Now, as an exercise, use \fBQed\fP
for a while until you feel comfortable with
the use of backslashes.  If you find them
confusing, work with
\fBQed\fP, doing fancy things if you feel up to it,
until the confusion disappears.
What follows will be much stranger ...

.SH "SPECIAL CHARACTERS (3)"
.sp
Now that we\(cqve established the ground rules,
we can begin to use some of the fancier stuff in \fBQed\fP.
.sp
The special character \f(CR\(rsl\fP (for \fIline\fP) returns a line of text from
standard input,
usually the user at the terminal. In other words,
if, say, input is coming from a buffer, then the input will be temporarily
redirected to come from the terminal.
The terminating newline is stripped away.
Since it is interpreted immediately (being a special character),
\f(CR\(rsl\fP is rarely of value
\fIexcept\fP when delayed. Nevertheless, let\(cqs look at how it behaves
in immediate mode:
.sp
.if n .RS 4
.nf
.fam C
""\(rslMessage\(rsN
        Message
""\(rslMessage

        Message
""\(rslMessage
s of words
        Messages of words
.fam
.fi
.if n .RE
.sp
The extra newline, whether provided by the \f(CR\(rsN\fP, or by a typed second
carriage return, is necessary because the \f(CR\(rsl\fP strips its
terminating newline away, but the comment (\f(CR""\fP) command is looking
for a newline itself in order to terminate.
.sp
[Some questions to consider:
If \f(CR\(rsbx\fP is used instead of \f(CR\(rsl\fP,
the second newline is not required.  Why?
In the last example above,
which characters are returned by \f(CR\(rsl\fP?
What is the origin of the others, if any?
What would the above examples do if
the comments were terminated with a double quote?]
.sp
Well, \f(CR\(rsl\fP is clearly of little use if not delayed,
but it \fIis\fP important to understand how it behaves.
.sp
An early version of U. of T. \fBQed\fP had only lower case buffer names,
and when the names \f(CR{\fP through \f(CR~\fP were added it was necessary
to go through the manual changing some of the instances of \f(CR`z\(aq\fP into
\f(CR`~\(aq\fP, but not all of them.
The following single line made the job very simple:
.sp
.if n .RS 4
.nf
.fam C
g/`z\(aq/ p ""replacement:" s//`\(rscl\(aq/p
.fam
.fi
.if n .RE
.sp
Each line (\f(CRg\fP) with a \f(CR`z\(aq\fP (\f(CR/`z\(aq/\fP) is printed (\f(CRp\fP),
the user is prompted for the
replacement (\f(CR""replacement:"\fP), and the response (\f(CR\(rsl\fP) \(em either a \f(CRz\fP or a \f(CR~\fP in our case \(em is substituted (\f(CRs//`\(rscl\(aq/\fP).
The single delay ensures that \f(CRg\fP places a literal \f(CR\(rsl\fP
in the substitution string,
which is then interpreted when each call to the substitute command
builds its replacement (\fIright\-hand side\fP) text.
This sort of operation can also be performed using an \f(CRx\fP command
driven by a global, but \fBQed\fP can be programmed
to do most of the work.
.sp
Here\(cqs another example:
.sp
.if n .RS 4
.nf
.fam C
bz ,d
ap ""Comment:\(rscl" s|$|        /* \(rscl */|p
        ""Comment:\(rsl" s|$|        /* \(rsl */|p
.fam
.fi
.if n .RE
.sp
On any line which invokes this buffer with a \f(CR\(rsbz\fP, the first \f(CR\(rsl\fP
in the comment will \(lqeat\(rq any input remaining
on the line after the \f(CR\(rsbz\fP (and inserts it into the comment command (\f(CR""\fP)
where the first \f(CR\(rsl\fP appears, namely after the \f(CR:\fP. Perhaps not very useful!).
.sp
.if n .RS 4
.nf
.fam C
ba a        c.code;
\(rsbz
        Comment:stylish                                \fB(1)\fP
                c.code;        /* stylish */

a        more.code;
\(rsbz foobar
        Comment:foobarstylish                \fB(2)\fP
                more.code;        /* stylish */
.fam
.fi
.if n .RE
.TS
tab(:);
r lw(\n(.lu*75u/100u).
\fB(1)\fP\h'-2n':T{
Prompt is \f(CRComment:\fP, user types \f(CRstylish\fP
T}
\fB(2)\fP\h'-2n':T{
Prompt is \f(CRComment:foobar\fP (\fIsic!\fP), user types \f(CRstylish\fP
T}
.TE
.sp
(Also, of course, if what the user typed at the prompt contains the character
\f(CR|\fP, problems will occur.)
.sp
Now, if we intend to be able to type our C comment text
on the same line as the invocation of the buffer,
as if passing it as an argument,
we want neither the \f(CRComment:\fP message nor
the extra \f(CR\(rsl\fP which clears the input line. Assuming buffer \f(CRz\fP still contains
our commenting program, let\(cqs edit out the \f(CRComment:\(rsl\fP prompt, and
try it again:
.sp
.if n .RS 4
.nf
.fam C
bz s/".*" //p
        s|$|        /* \(rsl */|p
ba a        yetmore.code;
\(rsbzstylish
                yetmore.code;              /* stylish */
.fam
.fi
.if n .RE
.sp
This latter form is likely more useful,
as it can be called from a global
(the previous version could, but required the user
to type extra newlines).
For example, to comment all occurrences of a variable named \f(CRvar\fP:
.sp
.if n .RS 4
.nf
.fam C
g/\(rs{var\(rs}/ p \(rscbz
.fam
.fi
.if n .RE
.sp
Each line is printed, and the user\(cqs response is appended as a C
comment.
No extra \f(CR\(rsl\fP is needed at the end to clear the input line
as the \f(CRg\fP already reads the line up to and including the terminal newline.
Thus the single \f(CR\(rsl\fP in the \f(CRs\fP command in buffer \f(CRz\fP
returns the next line typed in.
Note that the \f(CR\(rsbz\fP command is delayed so that it is interpreted
for each selected line.
.sp
We could alternatively have set up our \f(CRz\fP buffer so that the \f(CR\(rsl\fP itself
was delayed, using \f(CR\(rscl\fP instead.
The buffer could then be invoked (in a global command) as \f(CR\(rsbz\fP,
without the delay.
.sp
In effect, then, the \f(CRc\fP in the original buffer call \f(CR\(rscbz\fP above acts to delay
the \f(CR\(rsl\fP.  If the buffer had only literal text,
no delay would be necessary.
Our choice of where to put the delay
was made by wanting the buffer to be invocable directly from
the keyboard.
.sp
Just for the record,
note that we can achieve the effect of \f(CR\(rscb\fP above by
typing \f(CR\(rs\(aqb\fP, although the manner in which it works
is quite different.
.sp
Although these examples are somewhat low\-key,
they do begin to show how the parts of \fBQed\fP fit together.
Later, we will see how the \f(CR\(rsl\fP can be used
to control execution of commands.

.SH "REGISTERS"
.sp
\fBQed\fP has 56 registers, with the same names as the buffers:
\f(CRa\fP to \f(CRz\fP, \f(CRA\fP to \f(CRZ\fP, \f(CR{\fP, \f(CR|\fP, \f(CR}\fP, and \f(CR~\fP.
Buffers and registers are otherwise unrelated.
The registers are used to store simple text and short
command sequences.
In fact, most of the command buffers we have created
so far would be better suited to storage in registers;
buffers are generally used for storage of file text proper
and multiline command sequences.
The two main advantages of using registers to store text
are:
they can be set and manipulated without leaving the current buffer,
and they do not appear in the output from \f(CRn\fP commands,
which is significant because a user may typically have
twenty or more defined registers.
.sp
Registers are manipulated with the \f(CRz\fP (for \fIzdring\fP!) command.
The character after the \f(CRz\fP is the name of the register being
operated on,
and the next character is an \fIoperation code\fP.
The most straightforward operations are assignment (\f(CR:\fP) and printing (\f(CRp\fP):
.sp
.if n .RS 4
.nf
.fam C
za:procrastination
zap
        procrastination
.fam
.fi
.if n .RE
.sp
The string being assigned to the register is terminated by a newline.
If a newline is to be embedded in the register, \f(CR\(rsN\fP provides
the cleanest mechanism:
.sp
.if n .RS 4
.nf
.fam C
za:line1\(rscNline2
zap
        line1\(rsNline2
a
\(rsza
\&.
\-,p
        line1
        line2
.fam
.fi
.if n .RE
.sp
As a cconvenience, \fBQed\fP also allows multi\-line assignment
to a register by escaping a literal newline with \f(CR\(rs\fP :
.sp
.if n .RS 4
.nf
.fam C
za:line1\(rs
line2
zap
        line1
        line2
a
\(rsza
\&.
\-,p
        line1
        line2
.fam
.fi
.if n .RE
.sp
Registers are invoked in the obvious way: \f(CR\(rsza\fP inserts the
contents of register \f(CRa\fP into the input stream.
Note in the above example that the append (\f(CRa\fP) could not be done
on one line,
as the embedded newline in the register would cause the
first line (\f(CRline1\fP) of the register to be appended,
and the second (\f(CRline2\fP) to be interpreted as (ill\-formed) command input:
.sp
.if n .RS 4
.nf
.fam C
zap
        line1\(rsNline2
a \(rsza
        line1
        ?za10 ?x
.fam
.fi
.if n .RE
.sp
This is another example of embedded newlines causing trouble:
be careful!
.sp
There are many \fIoperation characters\fP for registers;
they are listed in full in the \f(CRqed(1)\fP manual section.
For example, we can perform a substitute operation on the
contents of the register with \f(CRzas/xxx/yyy/\fP (the same syntax
as for the substitute command \f(CRs\fP);
increment and decrement the Unicode codepoint values of the characters
in the register with \f(CRza+N\fP and \f(CRza\-N\fP, where \f(CRN\fP is an integer;
and do subzdring (!) operations with the \fItake\fP and \fIdrop\fP functions
\f(CRza)N\fP and \f(CRza(N\fP.
One particularly handy form is
.sp
.B register set to match
.br
.sp
.if n .RS 4
.nf
.fam C
za/regular expression/
.fam
.fi
.if n .RE
.sp
which saves in register \f(CRa\fP the string in the current line
which matches the regular expression.
There are several other register operations we will introduce
when required.
.sp
These operations are quite straightforward; we will see them
all used when we start to program \fBQed\fP.
.sp
Registers can also be manipulated numerically. This is indicated
by the \f(CR#\fP (for \fInumber\fP) operation: \f(CRza#...\fP . The text following
the \f(CR#\fP is then interpreted specially. Decimal numbers (integers)
stand for themselves, and numeric assignment to the register is \f(CR:\fP. So:
.sp
.if n .RS 4
.nf
.fam C
za#:42
zap
        42
za#:\-42
zap
        \-42
.fam
.fi
.if n .RE
.sp
In this numeric\-register context, the letters \f(CRa\fP, \f(CRr\fP,
\f(CRn\fP, \f(CRN\fP, \f(CRp\fP and \f(CRP\fP have special meanings. For example \f(CRp\fP means
\fIprint the current value of the register\fP. We will look at \f(CRa\fP and \f(CRr\fP
shortly.
The rest are described in the \f(CRqed(1)\fP manual. We can chain numeric
operations together (without spaces):
.sp
.if n .RS 4
.nf
.fam C
za#:42p
        42
za#:\-42p:99p
        \-42
        99
zap
        99
.fam
.fi
.if n .RE
.sp
In the last example, \-42 is assigned (\f(CR:\-42\fP) to \f(CRa\fP, then the current value
of \f(CRa\fP is printed (\f(CRp\fP), then 99 is assigned (\f(CR:99\fP) to \f(CRa\fP, and the
current value of \f(CRa\fP is again printed. Register \f(CRa\fP
contains 99 at the end of the numerical context.
.sp
In this numeric context, the value of the register can be updated by
one of the arithmetic operations \f(CR+\fP, \f(CR\-\fP, \f(CR*\fP, \f(CR/\fP, and \f(CR%\fP, which
have their familiar C language meanings:
.sp
.if n .RS 4
.nf
.fam C
za#:1
za#+1p
        2
za#*2p
        4
za#*2+1p
        9
.fam
.fi
.if n .RE
.sp
Numeric\-register context ends at the first character which is invalid
in a numeric\-register context, or the first newline, whichever comes first.
When numeric\-register context ends, the entire \f(CRz...\fP register command
ends, and \fBQed\fP will start processing any remaining characters on the
line as regular \fBQed\fP commands. This can have some bizarre side\-effects:
.sp
.if n .RS 4
.nf
.fam C
ba Z
a foo.bar;
za#:99p
        99
za#:99 p
        foo.bar;
.fam
.fi
.if n .RE
.sp
In \f(CRza#:99 p\fP, the space (after the \f(CR99\fP) is \fInot\fP a valid character in
numeric\-register context, so it terminates the \f(CRza#:99\fP command. The
remainder of the line (` p`) is then interpreted as a regular \fBQed\fP
command (namely, \fIprint the current line\fP), which it duly does.
.sp
It is an error (\f(CR?#\fP) to try to perform numeric operations on a register
which does not contain a (possibly negative) decimal integer:
.sp
.if n .RS 4
.nf
.fam C
za:44moose
za#*2
        ?#
.fam
.fi
.if n .RE
.sp
The main difference between \f(CRzap\fP and \f(CRza#p\fP is semantic.
In \f(CRzap\fP, the contents of register \f(CRa\fP are interpreted as
a string, and the (string\-)register operation \f(CRp\fP prints the
string held in \f(CRa\fP. In \f(CRza#p\fP, the contents of register \f(CRa\fP
are interpreted in numeric context, and the numeric\-register
operation \f(CRp\fP prints the (numeric) value in \f(CRa\fP. In practice,
the outcome of \f(CRzap\fP and \f(CRza#p\fP is the same if \f(CRa\fP contains a decimal integer.
.sp
Perhaps the most important use of numeric\-register operations
is in addressing.
The numeric\-operation character \f(CRa\fP causes the register to receive
the line number of the address of the \f(CRz\fP command:
.sp
.if n .RS 4
.nf
.fam C
$za#a
.fam
.fi
.if n .RE
.sp
assigns to register \f(CRa\fP the line number of the last line (\f(CR$\fP), \fIi.e.\fP the
number of lines in the current buffer; and
.sp
.if n .RS 4
.nf
.fam C
/xxxx/za#a
.fam
.fi
.if n .RE
.sp
saves in \f(CRza\fP the address of the first forward occurrence of \f(CRxxxx\fP.
.sp
The \f(CRr\fP operation character (for \fIrange\fP)
stores the first given address in the named register,
and the second address in the register whose name is
lexically one greater:
.sp
.if n .RS 4
.nf
.fam C
1,$ za#r
,za#r
.fam
.fi
.if n .RE
.sp
Both put \f(CR1\fP in register \f(CRa\fP and the value of \f(CR$\fP in register \f(CRb\fP.
Neither \f(CRa\fP nor \f(CRr\fP
changes the value of \fIdot\fP.
.sp
These operations are usually used to pass addresses to an execution buffer:
if the first line of a buffer is
.sp
.if n .RS 4
.nf
.fam C
za#r
.fam
.fi
.if n .RE
.sp
then if the buffer is invoked as, say,
.sp
.if n .RS 4
.nf
.fam C
\-5,.\(rsbz
.fam
.fi
.if n .RE
.sp
then registers \f(CRa\fP and \f(CRb\fP
contain the addresses of the first and last lines of
the range to be operated on by the buffer.
.sp
Numerical operations are also frequently useful in text editing,
such as when generating defined constants for a table:
.sp
.if n .RS 4
.nf
.fam C
a
read
write
open
close
creat
\&.
" capitalize
?read?,.s/.*/^/p
        CREAT
za#:0
?READ?,.g/^/s/.*/#define &        \(rscza/p za#+1
        #define READ        0
        #define WRITE        1
        #define OPEN        2
        #define CLOSE        3
        #define CREAT        4
.fam
.fi
.if n .RE
.sp
The \f(CR^\fP (caret) character in the right hand side of a substitute
behaves like \f(CR&\fP, but flips the case of ASCII alphabetics in the matched string.

.SH "CONTROL STRUCTURES"
.sp
The most commonly used control structure in \fBQed\fP is certainly
the global command, \f(CRg\fP, which is remarkably powerful and versatile,
as the previous example demonstrates.
The ability to place several commands on a line,
and the simplicity of \f(CR\(rsN\fP, make globals even easier to use in \fBQed\fP
than in \fBEd\fP.
.sp
Along with the concept of line\-by\-line execution goes that of
buffer\-by\-buffer execution, which is provided in \fBQed\fP
by the \fIglobuf\fP commands \f(CRG\fP and \f(CRV\fP.
They are quite simple to use:
their format is identical to the regular globals \f(CRg\fP and \f(CRv\fP,
but the regular expression is used to match the
output which would be produced by an \f(CRf\fP command in each buffer.
Only buffers which contain text or have a remembered file name
are tested for a match.
If a buffer matches the regular expression, the command list
is executed in that buffer.
For example,
.sp
.if n .RS 4
.nf
.fam C
G/.\(aq.*        ./w
.fam
.fi
.if n .RE
.sp
writes out (\f(CRw\fP) all buffers which have been modified since
last written. That is, all buffers which the \f(CRf\fP command
reports with a prime (\f(CR\(aq\fP) after the buffer name.
The white space in the above example is a tab,
which is the actual delimiter used by the \f(CRf\fP (and \f(CRn\fP) commands
between the number of lines in the buffer and the file name.
Here\(cqs a fancier example:
.sp
.if n .RS 4
.nf
.fam C
G/./ g/thing/ ""\(rscB \(rscf: " p
.fam
.fi
.if n .RE
.sp
It takes all non\-null buffers (\f(CRG/./\fP), and
for each one it looks for occurences of \f(CRthing\fP (\f(CRg/thing/\fP). Whenever
it finds one, it
prints out (\f(CR""..."\fP) the buffer (\f(CR\(rsB\fP), the file name (\f(CR\(rsf\fP), and
line (\f(CRp\fP). It\(cqs a bit like a super\-grep, or \fIGregrep\fP.
.sp
\fBQed\fP has a \fIloop\fP control structure, the \f(CRh\fP command (for \fIh\-until\fP!).
\f(CRh\fP, like \f(CRg\fP, takes a line of commands and executes it repeatedly.
It has four forms:
.sp
.B loop
.br
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBhN\fP\fP        executes the line N times
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBht\fP\fP        executes the line until the \fItruth flag\fP is true
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBhf\fP\fP        executes the line until the \fItruth flag\fP is false
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBha\fP\fP        (for \fIalways\fP) executes the line forever, or until an error
.RE
.RE
.sp
Although the loop is an \fIuntil\fP,
.sp
.B no\-op
.br
.sp
.if n .RS 4
.nf
.fam C
h0 p
.fam
.fi
.if n .RE
.sp
is guaranteed to execute zero times. An infinite loop
can be halted by sending Ctrl\0+\0C from the terminal.
.sp
The \fItruth flag\fP is set by substitutions, and comparison operations
in registers.
When a register is compared to some value, the truth flag is
set according to the success of the comparison.
When a substitution is made, the truth flag is set
if a substitution was performed.
As a simple example, say you have prepared a letter to be sent to
someone, using \fBQed\fP, only to find that the erase character
is a backspace, not \f(CR#\fP as you had been using.
To fix the problem,
.sp
.if n .RS 4
.nf
.fam C
g/^/ hf s/.#//
.fam
.fi
.if n .RE
.sp
Note that \fIhuntil\fP\-s can be run inside globals,
and, in fact, can be nested arbitrarily deep.
Globals can also be run from \fIhuntils\fP;
the only restriction is that globals cannot be called
from globals, as \fBQed\fP can only mark a line for a global once.
Similarly, \fIglobufs\fP cannot be called from \fIglobufs\fP.
.sp
.B Exercise
.br
.RS 4
.sp
Change the example where \f(CRz\fP\-s were replaced by \f(CR~\fP\-s
so that it works properly when there is more than one \f(CRz\fP on a line.
.RE
.sp
As in globals, \fIhuntil\fPs stop the scan of the command sequence
at the first newline.
To build an alphabet in register \f(CRA\fP:
.sp
.if n .RS 4
.nf
.fam C
za:a
zA:
h26 zAs/$/\(rscza/ za+1
zAp
        abcdefghijklmnopqrstuvwxyz
.fam
.fi
.if n .RE
.sp
Note that \fBQed\fP code is not always easy to read!
If you happen to know that the character which precedes \f(CRa\fP in Unicode
is back\-quote (\f(CR`\fP), you could also build the alphabet with:
.sp
.if n .RS 4
.nf
.fam C
za:`
zA:
h26 za+1 zAs/$/\(rscza/
zAp
        abcdefghijklmnopqrstuvwxyz
.fam
.fi
.if n .RE
.sp
And now, register \f(CRa\fP could also be used in \fIauto\-increment mode\fP to simplify
things further:
.sp
.if n .RS 4
.nf
.fam C
za:`
zA:
h26 zAs/$/\(rscz+a/
zAp
        abcdefghijklmnopqrstuvwxyz
.fam
.fi
.if n .RE
.sp
The \f(CR+\fP between the special character \f(CR\(rsz\fP and the \f(CRa\fP
in the register call causes the
values of the Unicode codepoints of the character(s) in \f(CRa\fP to be incremented
before being placed in the input stream:
.sp
.if n .RS 4
.nf
.fam C
za:moose
""\(rsz+a
        npptf
.fam
.fi
.if n .RE
.sp
\fIAuto\-decrements\fP are also possible (\f(CR\(rsz\-a\fP) as are numerical
increments and decrements (\f(CR\(rsz#+a\fP and \f(CR\(rsz#\-a\fP).
Only auto\-increments of +1 and auto\-decrements of \-1 are possible.
.sp
As a less frivolous example (one that was used in writing an earlier
version of this
tutorial), a \fIhuntil\fP makes it simple to convert, say, the \fItroff\fP
command \f(CR.ul 5\fP to five \f(CR.ul\fP\-s, one after each affected line:
.sp
.if n .RS 4
.nf
.fam C
g/^\(rs.ul [0\-9]+/ zn/[0\-9]+/ zn#\-1 s/ [0\-9]+// h\(rsczn +a .ul
.fam
.fi
.if n .RE
.sp
It looks horrible, but it works, and can save much trouble
if there are (as in the tutorial) twenty or more places
where the fix needs to be made.
(The \f(CR+\fP character in regular expressions is like \f(CR*\fP,
but guarantees at least one match.)
.sp
Of course, until familiarity with \fBQed\fP is developed,
the mental effort required to write a line like this and have
it work is probably considerably greater than the
physical effort required to type in the changes individually.
Even for beginning users, though, saving the complicated
patterns, and commands such as \f(CRap .ul\fP in registers
would make the job much more pleasant.
.sp
Again, care must be taken when invoking registers or buffers in
\fIhuntil\fP\-s:
.sp
.if n .RS 4
.nf
.fam C
h20 \(rsbz
" or "
h20 \(rscbz
.fam
.fi
.if n .RE
.sp
will likely not do what is expected if buffer \f(CRz\fP contains
more than one line.
.sp
The other major new control structure in \fBQed\fP is the \f(CRy\fP command
(for \fIyump;\fP
think of \fIjump\fP pronounced with a Swedish accent).
The syntax is:
.sp
.B jump
.br
.sp
.if n .RS 4
.nf
.fam C
y[t|f][N|o|\(aqlabel|`label]
.fam
.fi
.if n .RE
.sp
which translates as follows:
If the \f(CRt\fP or \f(CRf\fP is present,
jump only if it matches the \fItruth flag;\fP
otherwise jump unconditionally.
The \f(CRN\fP, if present, is a number, and is interpreted
as a line number in the current
executing buffer, which becomes the next line read for commands.
An \f(CRo\fP (for \fIout\fP) causes the current input source,
such as a global command string or buffer, to be terminated.
If the input source is a buffer, the effect is to return from the buffer;
if a global, the execution of the global (or \fIhuntil\fP) is stopped.
For example,
.sp
.if n .RS 4
.nf
.fam C
za#:1
h50 za#+1 za#>20 yto
zap
        21
.fam
.fi
.if n .RE
.sp
executes 21 times, leaving register \f(CRa\fP set to 21.
.sp
The forms
.sp
.B conditional jump forward to label
.br
.sp
.if n .RS 4
.nf
.fam C
y[t|f]\(aqlabel
.fam
.fi
.if n .RE
.sp
and
.sp
.B conditional jump backward to label
.br
.sp
.if n .RS 4
.nf
.fam C
y[t|f]`label
.fam
.fi
.if n .RE
.sp
are similar to \f(CRy[t|f]N\fP, but the line to which control is transferred
is the first line found which begins with the comment \f(CR"label\fP,
searching forward in the buffer in the case of \f(CRy[t|f]\(aqlabel\fP; or
backward in the buffer in the case of \f(CRy[t|f]`label\fP (where the
operation character is a \fIback\-tick\fP).
Initial blanks and tabs on the line before the comment character \f(CR"\fP
are ignored, and the scan of the
label stops at the first blank, tab, newline or double quote.
If the first character after the double quote is a space, tab,
newline or double quote, the label is null and can never be matched.
If no matching label is found in the executing buffer,
execution resumes at the first
character after the label in the \fIyump\fP command.
Note that the label must be matched exactly;
it is not interpreted as a regular expression.
.sp
There are a few non\-trivial small examples
which illustrate the use of \fIyumps,\fP
but they will be used later on in the tutorial.
For the moment, a remark on style:
clearly, with only a \fIgoto,\fP flow of control in \fBQed\fP
can become messy if care is not taken.
It is recommended that \fIyump\fP\-s only be used in
easily identifiable forms such as \fIif ... then ... else ...\fP:
.sp
.B if <condition> then ... else ...
.br
.sp
.if n .RS 4
.nf
.fam C
<condition> yf\(aqelse
    ...
y\(aqfi
"else
    ...
"fi
.fam
.fi
.if n .RE
.sp
and, \fIdo ... until ...\fP
.sp
.B do ... until <condition>
.br
.sp
.if n .RS 4
.nf
.fam C
"do
    ...
    <condition> yf`do
"od
.fam
.fi
.if n .RE
.sp
or, \fIwhile ... do ...\fP
.sp
.B while <condition> do ...
.br
.sp
.if n .RS 4
.nf
.fam C
"{
    <condition> yf\(aq}
    ...
    y`{
"}
.fam
.fi
.if n .RE
.sp
One particularly useful form of labeled \fIyump\fP\-s is a \fIswitch\fP statement
based on a line of input from the user.  This mechanism makes
command interpretation very simple.
It is essentially a fancy switch statement:
.sp
.B switch
.br
.sp
.if n .RS 4
.nf
.fam C
y\(aqX\(rsl
"default:
    ...
    yo
"Xcase1
    ...
    yo
"Xcase2
    ...
    yo
\&...
.fam
.fi
.if n .RE
.sp
One other form of \fIyump\fP exists; it is intended primarily to
skip the rest of a \fIglobal\fP or \fIhuntil\fP command sequence, without
stopping the execution completely.
Its form is simply \f(CRyt\fP, or \f(CRyf\fP.
When invoked, it jumps over the current input source
up to and including the next newline.
It can also be used as a shorthand in buffers,
but such usage is discouraged.

.SH "CALLING THE SHELL"
.sp
\fBQed\fP has three methods of calling the Shell aside from the \f(CR!\fP (\fIbang\fP)
command: \fIcrunch\fP (\f(CR<\fP), \fIzap\fP (\f(CR>\fP), and \fIpipe\fP (\f(CR|\fP). All of these
commands cause the \fBUNIX\fP commandline they last invoked to be stored in
register \f(CRU\fP. This commandline can be recalled by doubling the command
character, as if the command \f(CR\(rs\(aqzU\fP was issued:
.sp
.if n .RS 4
.nf
.fam C
!echo fun
        fun
        !
zUp
        echo fun
!!
        fun
        !
.fam
.fi
.if n .RE
.sp
You can even extend the saved commandline:
.sp
.if n .RS 4
.nf
.fam C
!! | wc \-c
        4
        !
zUp
        echo fun | wc \-c
.fam
.fi
.if n .RE
.sp
And edit it, just like any other register:
.sp
.if n .RS 4
.nf
.fam C
zUs/fun/funny/
!!
        6
        !
zUp
        echo funny | wc \-c
.fam
.fi
.if n .RE
.sp
\fICrunch\fP (\f(CR<\fP) takes the standard output from the Shell command
and reads it into the current buffer,
as if the output from the
Shell command had been redirected to a temporary file,
which is then read in with an \f(CRr\fP command.
Like the \f(CRr\fP command, \f(CR<\fP takes an optional address which
specifies the line (defaulting to \f(CR$\fP) at which
the text is to be read in.
(As above, the \fBUNIX\fP  command last executed
can be reinvoked, as a \fIcrunch\fP, with \f(CR<<\fP.)
.sp
.if n .RS 4
.nf
.fam C
< ls
        !
.fam
.fi
.if n .RE
.sp
appends a list of the files in the current directory to the end
of the buffer.
.sp
One very common usage of the crunch command is to
create a to\-do list, by a command such as
.sp
.if n .RS 4
.nf
.fam C
< grep "FIX ME!" *.c
        !
.fam
.fi
.if n .RE
.sp
or using a buffer as a sort of checklist by
capturing diagnostic output from a compiler, say:
.sp
.if n .RS 4
.nf
.fam C
bz Z
< cc \-c *.c | tee /dev/tty
        ... diagnostic messages ...
        !
.fam
.fi
.if n .RE
.sp
saves the listing of the compile errors so you can let \f(CRcc\fP
run through everything before fixing typing mistakes, etc.
.sp
\fIZap\fP (\f(CR>\fP) is to \fIcrunch\fP as \f(CRw\fP is to \f(CRr\fP: it writes out the contents
of the addressed lines (defaulting to the entire current buffer)
as standard input to the Shell command.
It is can be used to send e\-mail.
The e\-mail can be prepared in a buffer, edited as desired,
and then sent easily by
.sp
.if n .RS 4
.nf
.fam C
> mail joe
        !
.fam
.fi
.if n .RE
.sp
or even
.sp
.if n .RS 4
.nf
.fam C
> nroff | mail joe
        !
.fam
.fi
.if n .RE
.sp
\fIZap\fP and \fIcrunch\fP work nicely together.
We can perform an interactive file\-delete function,
(like the ancient \f(CRdsw\fP command) using \fIcrunch\fP
to read the files in,
modifying the list as appropriate,
and sending it out to (another ancient command) \f(CRargs\fP:
.sp
.if n .RS 4
.nf
.fam C
< ls
        !
\&... editing commands ...
> args rm
        !
.fam
.fi
.if n .RE
.sp
(\f(CRargs\fP was a command that took each line on its standard input
and maked it an argument to the command,
which was then \f(CRexec\fP\-ed in the normal manner.)
.sp
The following commands can initiate the construction of
a dependency\-list file for \f(CRmake\fP:
.sp
.if n .RS 4
.nf
.fam C
<grep "#include" *.c
        !
,s/:#include[         ]"/         //
,s/"$//p
        utfio.c        qed.h
.fam
.fi
.if n .RE
.sp
At U. of T., the Shell takes a \f(CR\-e\fP option which tells it to
echo on the diagnostic output
the commands it is executing, which works nicely with \fIzap:\fP
.sp
.if n .RS 4
.nf
.fam C
a
command1
command2
command3
\&.
> sh \-e
        % command1
        % command2
        % command3
        !
.fam
.fi
.if n .RE
.sp
In short, the \fIcrunch\fP and \fIzap\fP commands are used very frequently.
.sp
The \fIpipe\fP command (\f(CR|\fP) is very similar to \fIcrunch\fP. Whereas
\fIcrunch\fP takes a single address, and \fIinserts\fP the standard output
of the commandline at that address,
\fIpipe\fP takes an address range, and it \fIreplaces\fP
the addressed range with the standard output of its commandline.
The default address range for \fIpipe\fP is the entire buffer (\f(CR1,$\fP),
so the command \f(CR< ls\fP will append a directory listing to the current
buffer, but the command \f(CR| ls\fP will \fIreplace\fP the contents of the
buffer with the directory listing.

.SH "PROGRAMMING (1)"
.sp
Now that we\(cqve seen all the primitives,
we can begin using buffers and registers to build
more sophisticated commands.
The first step is to
assemble a few useful command sequences in
registers.
Harking back to our function\-declaration\-finding
buffer in Section 3, define register \f(CRf\fP (for \fIfunction\fP):
.sp
.if n .RS 4
.nf
.fam C
zf:?^[a\-zA\-Z_].*(?
zfp
        ?^[a\-zA\-Z_].*(?
.fam
.fi
.if n .RE
.sp
As a \fIglobal\fP search, the regular expression \f(CR/^[a\-zA\-Z_].*(/\fP found
all function declarations, provided, of course,
that the usual paragraphing style is used.
.sp
.B Exercise
.br
.RS 4
.sp
Write another definition to perform this function
which uses the \fIbeginning of identifier\fP (\f(CR\(rs{\fP) metacharacter.
.RE
.sp
Now, with the regular expression enclosed in \f(CR?...?\fP,
register \f(CRf\fP
finds the first \fIprevious\fP
function declaration.
This seems like an odd concept at first, but works well.
For example,
to see which function\(cqs source is being browsed:
.sp
.if n .RS 4
.nf
.fam C
\(rszf
        function(x)
.fam
.fi
.if n .RE
.sp
Or, to find the declaration of a local variable:
.sp
.if n .RS 4
.nf
.fam C
p
            variable=0;
\(rszf/variable/
            int variable;
.fam
.fi
.if n .RE
.sp
(This works by searching back to the closest previous function definition
using the saved command (\f(CR\(rszf\fP) and then searching forward for the
first occurence of the name \f(CRvariable\fP with \f(CR/variable/\fP.)
.sp
To print out to the line printer the listing of the
function currently being browsed:
.sp
.if n .RS 4
.nf
.fam C
\(rszf, /^}/ > lpr
.fam
.fi
.if n .RE
.sp
There are fancier things, too.
If we want to know which subroutines call \f(CRproc()\fP,
we can again use \f(CR\(rszf\fP:
.sp
.if n .RS 4
.nf
.fam C
g/proc()/\(rszf
        func1(x)
        func2(y)
        func3()
.fam
.fi
.if n .RE
.sp
After using macros like \f(CR\(rszf\fP for a while,
they become familiar to the point
that they become idiomatic, a part of the \fBQed\fP language.
To help the user develop a personal working environment,
\fBQed\fP provides
a simple mechanism for initializing.
Typing
(to the Shell)
.sp
.if n .RS 4
.nf
.fam C
$ qed \-x qfile file1 file2
.fam
.fi
.if n .RE
.sp
causes \fBQed\fP to load the file named \f(CRqfile\fP into buffer \f(CR~\fP (\fItilde\fP)
\fBand execute it,\fP before reading in the
files to be edited (\f(CRfile1\fP, \f(CRfile2\fP), and beginning the normal editing session.
Typically, the startup file is used to initialize options
and registers; it might contain something like:
.sp
.B qfile listing
.br
.sp
.if n .RS 4
.nf
.fam C
""Qed
zc:s|$|        /* \(rscl */|p
zf:?^[a\-zA\-Z_].*(?
b~Z    " destroy buffer after execution
.fam
.fi
.if n .RE
.sp
which prints a message (\f(CRQed\fP);
defines a couple of handy registers (\f(CRzc\fP and \f(CRzf\fP);
and obliterates itself (\f(CRb~Z\fP).
If no \f(CR\-x\fP option is given when \fBQed\fP is invoked,
\fBQed\fP will try to load the file named by the (Shell) environment variable
\f(CRQEDFILE\fP into register \f(CR~\fP, and run that instead. If the variable
\f(CRQEDFILE\fP is undefined then no startup file is loaded.
.sp
Browsing through the startup files of a few experienced \fBQed\fP hacks,
a few interesting things come to light.
One simple but rather pretty option was
.sp
.if n .RS 4
.nf
.fam C
ob""\(rscx1a"+p
.fam
.fi
.if n .RE
.sp
Character \f(CR\(rsx1A\fP was a \fIreverse line\-feed\fP on most of the U. of T. terminals;
The \fIbrowse option\fP (\f(CRob\fP) defines a special register
which is executed, if defined, when a simple newline
is typed at the terminal, rather than doing the default \f(CR+p\fP
(\fIprint next line\fP).
Printing a reverse line\-feed before the \f(CR+p\fP means
that no empty lines appear on the screen when browsing through
text.
.sp
On a modern terminal the equivalent ANSI escape sequence version
would be:
.sp
.if n .RS 4
.nf
.fam C
ob""\(rsx1b[F"+p
.fam
.fi
.if n .RE
.sp
It is sometimes useful to set the browse register to
something like \f(CR+b\fP for easy paging through text,
or to \f(CRP\fP or \f(CRL\fP, which cause the line to
be displayed in the format of \f(CRp\fP or \f(CRl\fP, but
with line numbers at the beginning of the line:
.sp
.if n .RS 4
.nf
.fam C
22i Line        22
p
        Line        22
l
        Line\(rst22
P
        22        Line        22
L
        22        Line\(rst22
.fam
.fi
.if n .RE
.sp
These other display formats are also sometimes handy in global searches:
.sp
.if n .RS 4
.nf
.fam C
g/proc()/ \(rszf P
        104        func1(x)
        118        func2(y)
        221        func3()
.fam
.fi
.if n .RE
.sp
Another nice register to have tucked away (as it is above) is the C\-commenting
command we saw earlier:
.sp
.if n .RS 4
.nf
.fam C
zc:s@$@        /* \(rscl */@ p
.fam
.fi
.if n .RE
.sp
We can call it up when desired:
.sp
.if n .RS 4
.nf
.fam C
p
        bizarre();
\(rszc(A Kludge)
        bizarre();        /* (A Kludge) */
g/xxxxx/ p \(rsczc
        yyy xxxxx yyy
needles
        yyy xxxxx yyy        /* needles */
        zzz xxxxx zzz
haystacks
        zzz xxxxx zzz        /* haystacks */
\&...
.fam
.fi
.if n .RE
.sp
The following register definition allows the user to
find a buffer by its file name:
.sp
.if n .RS 4
.nf
.fam C
zb:G/\(rscl/ f\(rscN
\(rszbfile
        g\(aq.34        file.c
.fam
.fi
.if n .RE
.sp
We don\(cqt even need to type the suffix \f(CR.c\fP!
.sp
Here is a rather complicated, but conceptually simple,
register, \f(CR\(rszs\fP (for \fIsearch\fP), which globally searches
for a pattern in all the buffers from \f(CRa\fP through \f(CRz\fP,
and leaves dot at the last occurrence found.
For readability, from here on, we will usually list the contents
of a register with real newlines in place of the \f(CR\(rsN\fP\-s, or the
escaped newlines, and without the delays to special characters, that would
be necessary when actually assigning the program to a register. Compare what
you would have to type at the keyboard to assign this program to
register \f(CRs\fP, with the listing that follows!
.sp
.B writing to zs at the terminal (with escaped newlines)
.br
.sp
.if n .RS 4
.nf
.fam C
zs:zB:\(rscB\(rs
zP:\(rscl\(rs
zI:`\(rs
h26 zI+1 b\(rscczI $zD#a=0 yt g/\(rsczP/ ""\(rsccB:" P zB:\(rsccB\(rs
b\(rsczB
.fam
.fi
.if n .RE
.sp
Or worse (this is all on \fBone\fP line!):
.sp
.B writing to zs at the terminal (with delayed newlines)
.br
.sp
.if n .RS 4
.nf
.fam C
zs:zB:\(rscB\(rscN zP:\(rscl\(rscN zI:`\(rscN h26 zI+1 b\(rscczI $zD#a=0 yt g/\(rsczP/ ""\(rsccB:" P zB:\(rsccB\(rscN b\(rsczB
.fam
.fi
.if n .RE
.sp
\fIVersus\fP a comparatively sane listing:
.sp
.B zs program listing
.br
.sp
.if n .RS 4
.nf
.fam C
zB:\(rsB
zP:\(rsl
zI:`
h26 zI+1 b\(rsczI $zD#a=0 yt g/\(rszP/ ""\(rscB:" P zB:\(rscB
b\(rszB
.fam
.fi
.if n .RE
.sp
But what does all this mean !?
One step at a time:
.sp
.B zs program walk\-through
.br
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBzB:\(rsB\fP\fP sets register \f(CRB\fP to the current buffer name;
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBzP:\(rsl\fP\fP sets register \f(CRP\fP to the rest of the commandline (\fIi.e.\fP
the user\-supplied pattern; if there were special characters
in the pattern, we would probably have to delay them once
more than usual to achieve the desired result.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBzI:`\fP\fP sets register \f(CRI\fP, a counter, to the character immediately
prior to \f(CRa\fP in Unicode.
.RE
.sp
The next line does all the work, and reads something like:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBh26\fP\fP \fIfor\fP 26 iterations \fIdo\fP
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBzI+1\fP\fP increment I (iterates over the alphabet)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBb\(rsczI\fP\fP switch to (new) buffer \(rszI
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fB$zD#a\fP\fP set D to the address of the last line of the buffer
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fB=0\fP\fP test for D = 0 ?
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fByt\fP\fP \fIif\fP (D=0) is true \fIthen\fP skip the rest of the line, resuming the next iteration
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBg/\(rszP/\fP\fP \fIelse\fP \fIfor\fP every line matching the given pattern \(rszP \fIdo\fP
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fB""\(rscB:"\fP\fP print the current buffer name and a colon
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBP\fP\fP print the matched line, with line number
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBzB:\(rscB\fP\fP set register B to the current buffer name
.RE
.RE
.RE
.sp
Finally, the last command
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBb\(rszB\fP\fP switch to buffer name in register \f(CRB\fP.
.RE
.RE
.sp
After execution, \f(CRzB\fP contains the last buffer name in which a match
was found, and \fBQed\fP automatically
keeps track of the line number on which the match was found.
The last line of \f(CRzs\fP therefore changes back to
buffer \f(CR\(rszB\fP, which leaves \fIdot\fP at the last
line printed, similar to the behaviour of \f(CRg/xxx/p\fP.
.sp
Got that?
.sp
Make sure you understand how the \f(CRs\fP register operates,
as it utilizes many of the standard \fBQed\fP programming techniques,
such as nesting a \fIglobal\fP inside a \fIhuntil\fP.
.sp
Well, that was instructive, but rather revolting.
If you understood how the search register works,
you\(cqre doing very well, but it\(cqs not a good example of
how to program \fBQed\fP, just a pedagogical one.
Here\(cqs how to \fIreally\fP do it:
.sp
.B globuf search program listing
.br
.sp
.if n .RS 4
.nf
.fam C
G/^[a\-z]/ g/\(rsl/ ""\(rscB:" P
.fam
.fi
.if n .RE
.sp
.B Exercise
.br
.RS 4
.sp
Modify this version so that it remembers the last buffer
in which a match was found.
.RE
.sp
You\(cqll find as you gain experience that \fIhuntil\fP\-s are rarely used,
but they do have their moments.
.sp
Using the register is quite easy;
just type \f(CR\(rszs\fP followed by the pattern being searched for:
.sp
.if n .RS 4
.nf
.fam C
\(rszs^func()
        a:86        func()
        b:102        func() {
f
        b .209        junk.c
.fam
.fi
.if n .RE
.sp
.B Exercise
.br
.RS 4
.sp
Set up your startup buffer to include
the original definition of \f(CRzs\fP
using delayed \f(CR\(rsN\fP\-s where necessary.
Is a delayed newline necessary at the end of the register?
Why, or why not?
(\fBHint:\fP Where does the newline at the end of the invocation line end up?)
Define a second register like \f(CRs\fP,
but which executes a definable register, say \f(CRe\fP, for \fIexecute,\fP
rather than just printing the line.
You can use our one\-liner version (above) that we stored in register \f(CRx\fP here.
What useful things might be put in register \f(CRe\fP?
.RE
.sp
Registers can also be used to call the Shell.
Register \f(CRd\fP, defined below,
calls \f(CRpwd\fP to
get the current directory, saving the result
in register \f(CRe\fP,
so that the user can quickly return after changing
working directory.
.sp
.if n .RS 4
.nf
.fam C
zd:ovr zB:\(rscB\(rscN bX <pwd \(rscN ze. d b\(rsczB ovs zep zB:
.fam
.fi
.if n .RE
.sp
This definition of register \f(CRd\fP is also exactly as it would appear
in a startup file.
The \f(CRze.\fP command
puts a copy of the current line in register \f(CRe\fP.
The delayed newlines are necessary; unpacked, the string looks like
.sp
.B zd program listing
.br
.sp
.if n .RS 4
.nf
.fam C
ovr zB:\(rsB
bX <pwd
ze. d b\(rszB ovs zep zB:
.fam
.fi
.if n .RE
.sp
Briefly: turn verbose mode off (\f(CRovr\fP);
save the current buffer name into register \f(CRB\fP (\f(CRzB:\(rsB\fP);
change to buffer \f(CRX\fP (\f(CRbX\fP) and get the directory (\f(CR<pwd\fP);
save it in register \f(CRe\fP (\f(CRze.\fP);
delete the line from the buffer (\f(CRd\fP);
change back to the original buffer (\f(CRb\(rszB\fP);
turn verbose mode back on (\f(CRovs\fP);
print the saved directory (\f(CRzep\fP);
and clear register \f(CRB\fP (\f(CRzB:\fP).

.SH "PROGRAMMING (2)"
.sp
So far, the emphasis has been on using registers as programming elements,
primarily because the size and complexity of the problems
being handled has been small enough that registers are really
the way to deal with them.
Ultimately, though,
more complicated problems arise and it becomes necessary to store
command sequences in buffers.
In light of that, one more register definition, \f(CRr\fP for \fIrun,\fP
will make using program buffers somewhat simpler.
Called as
.sp
.if n .RS 4
.nf
.fam C
\(rszrbuffer
.fam
.fi
.if n .RE
.sp
it reads file \f(CRbuffer.q\fP, prepended by the search path
stored in register \f(CRq\fP, into a scratch buffer, executes it,
and then clears the scratch buffer.
Typically, register \f(CRq\fP would be set by the startup buffer to contain
something like \f(CR/home/rob/q/\fP
so
.sp
.if n .RS 4
.nf
.fam C
\(rszrcommand
.fam
.fi
.if n .RE
.sp
runs the buffer in the file \f(CR/home/rob/q/command.q\fP.
Register \f(CRr\fP is long, but linear, having no loops.
As an unpacked listing, with newlines, it looks like:
.sp
.B zr program listing
.br
.sp
.if n .RS 4
.nf
.fam C
zL#r
z{:\(rsl
z|:\(rsB
ovr b{
e \(rszq\(rsz{.q
ovs b\(rsz| \(rsb{
b{ Z
b\(rsz|
.fam
.fi
.if n .RE
.sp
This looks considerably more bizarre than our earlier definitions,
because it follows some conventions that have proven useful.
The registers and buffers with funny names (\f(CR{\fP, \f(CR|\fP, \f(CR}\fP, and \f(CR~\fP)
are (unofficially) reserved as scratch areas: anything you put
in one is not guaranteed to stay there
if you call in an external buffer.
\f(CRzr\fP uses registers \f(CR{\fP and \f(CR|\fP to hold
the program name typed by the user and the buffer the register
was called from, and buffer \f(CR{\fP to hold the program.
\fBQed\fP itself uses register \f(CR~\fP to hold the initialization code
to bootstrap the startup buffer,
but clears it before going to the terminal for input.
(A side effect of this is that your startup buffer can
zap \f(CRz~\fP to alter the bootstrap procedure.)
.sp
Other conventions are that upper case registers and buffers
are reserved for use by program buffers, such as the ones
we will be developing in this section; and lower case letters
are reserved for the user.
.sp
\f(CRzr\fP stores in registers \f(CRL\fP and \f(CRM\fP the addressed
lines for the buffer being called
(via the \fIrange\fP operator: \f(CRzL#r\fP).
Following these conventions means that a user can call a copy of someone
else\(cqs program buffer, for example, without worrying about
which registers and buffers it uses.
.sp
The \f(CRovr\fP and \f(CRovs\fP calls in register \f(CRr\fP set the \fIverbose flag\fP
off and on when appropriate, to suppress the occasional
character counts on i/o.
The register as defined here actually works, but what we really want
is something a bit spiffier, so, let\(cqs have \f(CR\(rszr\fP load a
particular buffer file, which we will describe immediately afterwards:
.sp
.if n .RS 4
.nf
.fam C
zr:zL#r z}:\(rscB\(rscN ovr b~e \(rsczqrun\(rscN \(rscb~\(rscN b\(rscz}
.fam
.fi
.if n .RE
.sp
This loads buffer \f(CR~\fP with the file (say) \f(CR/home/rob/q/run.q\fP.
The buffer is then executed, and the user is returned to
the original buffer.
The \f(CRrun.q\fP buffer file contains:
.sp
.B run.q program listing
.br
.sp
.if n .RS 4
.nf
.fam C
" Run a qed buffer `off line\(aq
z{:\(rsl
z{C
" the next line puts a space at the end of the register
z{$
" the next line looks for a space in the argument string
z|\(aq{  z{[
z~#c  z{)\(rsz~  z|(\(rsz~  z|C
" z{: command   z|: argument string   z}: return buffer set by zr
b{ e \(rszq\(rsz{.q
ovs
b\(rsz} \(rsb{
" Note! ok to ZERO buffer ~ (this buffer); the line will finish executing
b{Z b~Z
.fam
.fi
.if n .RE
.sp
The \f(CRzXC\fP command is kludgey but handy:
it collapses multiple blanks and tabs in the register to single blanks,
and deletes leading blanks.
The first few lines of the buffer put the command and its arguments
(if present)
into registers \f(CR{\fP and \f(CR|\fP.
The new register commands introduced here are:
.sp
.B register commands
.br
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBzx[string\fP\fP stores in the \fIcount\fP the starting
index of \f(CRstring\fP in register \f(CRx\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBzy#c\fP\fP saves the \fIcount\fP in register \f(CRy\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBzx)N\fP\fP \fItakes\fP the first \f(CRN\fP characters from the register, and
discards the remainder
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR\fBzx(N\fP\fP \fIdrops\fP the first \f(CRN\fP characters from the register, and
preserves the remainder
.RE
.RE
.sp
Although it\(cqs a little unfair to show these commands
to you this late in the
game, they didn\(cqt really need showing earlier on, and they are
quite simple to master.
The \fIcount\fP also hasn\(cqt shown up before,
so we\(cqd best explain it now.
It is a special place, something like the \fItruth,\fP
which gets set to the number of characters transferred
during i/o operations; the number of substitions made during
an \f(CRs\fP command; and to other such numbers, as above.
Although rarely used, it, too, has its moments.
.sp
The requested buffer is then loaded into buffer \f(CR}\fP and executed.
Finally, the loaded buffer and buffer \f(CR~\fP are zeroed,
and \f(CRrun.q\fP returns.
.sp
Although its coding is not particularly pretty,
the power register \f(CRr\fP gives us is dramatic.
It is really part of the \fBQed\fP language,
since it allows the user to store
many command buffers in the file
system, but get at them easily and in a mnemonic fashion.
It itself employs two conventions which are therefore ubiquitous:
registers \f(CRL\fP and \f(CRM\fP hold the lines being addressed by a buffer call,
and buffers \f(CR{\fP and \f(CR~\fP are off\-limits to command buffers.
The latter point, of course, shows the weakness of a language
in which all the variables are global,
but let\(cqs ignore that theoretical issue for the moment:
\fBQed\fP has many other weaknesses which are far more important!
.sp
\f(CRzr\fP is only useful if we have some buffers to drive with it.
For starters, we can take our \f(CRsearch\fP register and put it in
a buffer (say \f(CR/home/rob/q/grep.q\fP):
.sp
.B grep.q file listing
.br
.sp
.if n .RS 4
.nf
.fam C
" Grep for z| (possibly set by caller) in all buffers
z|=
yf\(aqfi
        ""pattern:" z|:\(rsl
"fi
G/^[a\-zA\-Z]/ g/\(rsz|/ ""\(rscB:" P
.fam
.fi
.if n .RE
.sp
A few noteworthy points occur:
firstly, we can prompt the user for missing arguments.
If the user types
.sp
.if n .RS 4
.nf
.fam C
\(rszr grep expr
.fam
.fi
.if n .RE
.sp
(notice the blanks, which are deleted by the \f(CRrun\fP buffer)
we can search for \f(CRexpr\fP directly; but if no expression is
specified, we just ask for it.
.sp
Secondly, putting the code into a buffer means
everything can be delayed one less time, which makes it more
readable,
and the initialization and cleanup code is shared by all command buffers,
providing a clean and uniform interface.
Also, after execution, register \f(CRr\fP returns the user to the
buffer they started in, rather than leaving them in some random place.
For this example, it may or may not matter, but in some
cases it is advantageous to return \(oqhome\(cq.
.sp
Here is a new example.  It right justifies the addressed lines,
something of mild utility, but too special purpose to keep around
as a real program.
It only takes a couple of minutes, though, to write a \fBQed\fP buffer
to do it, which can then be saved away:
.sp
.B rjust.q program listing
.br
.sp
.if n .RS 4
.nf
.fam C
" Right justify addressed lines (default to (1,$))
zL#=\(rszM yf\(aqfi
        1,$zL#r
"fi
" The white space below is a space and a tab
\(rszL,\(rszMs/^[         ]*//
\(rszL,\(rszMs/[         ]*$//
zW:0
\(rszL,\(rszM g/^/ zC#l#<\(rsczW yt zW:\(rsczC
zW#>35 yf zW:35
zD:                           |
zD)\(rszW
\(rszL,\(rszM s/^/\(rszD/
" Turn spaces into periods
zD+14
\(rszL,\(rszM s/^ ,\(rs(\(rszD\(rs)$/\(rs1/
zD\-14
\(rszL,\(rszM s/^\(rszD//
zL:\(rsN zM:\(rsN zC:\(rsN zD:\(rsN zW:
.fam
.fi
.if n .RE
.sp
(Another new command (sorry!): \f(CRzC#l\fP sets register \f(CRC\fP
to the length of the current line.)
.sp
This buffer illustrates how command buffers use the \f(CR(zL,zM)\fP
address pair.
Clearing the registers afterwards is a good practice for program buffers
to follow.
.sp
.B Exercise
.br
.RS 4
.sp
Why is there no \f(CR\(rsN\fP on the end of the last line?
.RE
.sp
To invoke this program on a suitable buffer full of, say, words
one to a line, we save it away in
\f(CR/home/rob/q/right.q\fP and type:
.sp
.if n .RS 4
.nf
.fam C
ba        " where the data is
,p
        excle
        ficatings
        criminter
        con
        explasence
        des
        ofh
        fultesibe
        shispensitment
        dedgearing
        expers
" yes, they\(aqre random words
\(rszrright
,p
                 excle
             ficatings
             criminter
                   con
            explasence
                   des
                   ofh
             fultesibe
        shispensitment
            dedgearing
                expers
.fam
.fi
.if n .RE
.sp
As the \fIRonco\fP man would say, \(lqIsn\(cqt that amazing!\(rq
.sp
Can we do anything useful with all this power?
Well, we can write a buffer \f(CRun\fP (for \fIrun\fP or \fIunix\fP)
which pipes the addressed lines out to
a shell command line, and replaces them in the buffer
with the output of the command. This functionality is now largely provided
by the \fIpipe\fP command (\f(CR|\fP), but creating an implementation of \fIpipe\fP
in pure \fBQed\fP, is itself instructive:
.sp
.B un.q program listing
.br
.sp
.if n .RS 4
.nf
.fam C
" un.q \-\- replace addressed lines of current buffer by result
"          of passing them through pipeline
"          Looks in z| for pipeline; if empty, prompts & reads from terminal
"          Called as addr1, addr2 \(rszrun; defaults to (1,$).
z|=
yf\(aqfi
        ""<> "
        z|:\(rsl
"fi
zL#=\(rszM yf 1,$zL#r
ovr
\(rszL,\(rszM > \(rsz| > /tmp/qed
zT#t        " zT gets return status from truth
\(rszMr /tmp/qed
!rm /tmp/qed
ovs
zT#=0 yf\(aqelse
        ""Invalid status return \- lines not deleted
        y\(aqfi
"else
        \(rszL,\(rszMd
"fi
zL:\(rsNzM:\(rsNzT:
""!\(rsN
.fam
.fi
.if n .RE
.sp
The prompt is reminiscent of \fIcrunch\-zap\fP.
The \f(CRyf\(cqelse\fP tests the return status of the
command, and decides not to delete the original lines
if the status was bad (\fIi.e.\fP non\-zero).
Using the \f(CR\(rszrun\fP (\fIrun buffer\fP \f(CRun.q\fP) combination,
we can process the data in a buffer
through any arbitrary pipeline, such as
.sp
.if n .RS 4
.nf
.fam C
,p
        excle
        ficatings
        criminter
        con
        explasence
        des
        ofh
        fultesibe
        shispensitment
        dedgearing
        expers
\(rszrun sort
        !
,p
        con
        criminter
        dedgearing
        des
        excle
        expers
        explasence
        ficatings
        fultesibe
        ofh
        shispensitment
.fam
.fi
.if n .RE
.sp
To send out only a portion of the buffer to the pipeline,
the usual convention is used:
.sp
.if n .RS 4
.nf
.fam C
\&.,/ful/ \(rszrun sort
.fam
.fi
.if n .RE

.SH "FINAL COMMENTS"
.sp
\fBQed\fP is a large system,
but its concepts are, for the most part,
simple extensions from those of \fBEd\fP.
Although it provides no new functionality in \fBUNIX\fP,
it can greatly simplify many text\-manipulation
tasks,
ranging from day\-to\-day editing problems to production\-level
text processing.
By striking a harmonious balance between
\fBQed\fP and \fBUNIX\fP\(cqs other tools,
the intelligent user will find \fBQed\fP
powerful, flexible, easy to master, and fun!

.SH "EDITOR\(cqS NOTES"
.SS "Remarks"
.sp
The Tutorial really does assume fluency in \fBEd\fP. An
updated Tutorial for a modern audience should certainly begin
with an introduction to the line\-oriented editing
paradigm, and the basic \fBEd\fP\-like functionality in \fBQed\fP.
.sp
Some of the original examples are pretty anachronistic, and would
have seemed less exotic to someone sitting at a U. of T. terminal
back in the early \(aq80s. An updated Tutorial should choose
examples which would seem familiar to today\(cqs audience. Perhaps
some programs for doing common \f(CRgit\fP tasks.
.sp
The section on Registers needed a major overhaul, as the mini\-languages
used in register and numeric\-register operations had changed significantly.
.sp
There were surprisingly few typos in the original, quite a feat
considering that many of the examples had \fBQed\fP code interspersed
with \fItroff\fP code!
.SS "History"
.sp
Originally written by \fBRobert Pike\fP at U. of T. in 1992..
.sp
Converted to \f(CRasciidoc\fP, edited,
and updated by \fISean Jensen\fP in February 2021.
.SS "Resources"
.sp
Rob Pike\(cqs original U. of T. Qed tarball:
.URL "https://github.com/arnoldrobbins/qed\-archive/unix\-1992" "" ""
.sp
Sean Jensen\(cqs port of Qed, including this tutorial:
.URL "https://github.com/phonologus/QED" "" ""
.SH "SEE ALSO"
.sp
qed(1),
ed(1)
.SH "AUTHOR"
.sp
Robert Pike, Sean Jensen (ed.)